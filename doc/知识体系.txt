一、Maven
1、私服Nexus
私服是一个特殊的远程仓库，它是架设在局域网内的仓库服务；
Maven构建时，先从私服请求，如果私服上没有，则从外部的远程仓库下载，缓存在私服上；
好处：节省自己的外网带宽，加速Maven的构建，部署第三方构件，提高稳定性，增强控制，权限管理，降低中央仓库的负荷；
2、常用命令
mvn compile（编译类文件）
mvn package（打包）
mvn install（包含mvn compile，mvn package，然后上传到本地仓库）
mvn deploy（包含mvn install，然后，上传到私服）
mvn clean（清除target目录）
mvn -Dtest package（只打包不测试）
mvn clean install-U（强制检查更新）
mvn clean install-e（打印完整的堆栈，方便分析错误）
创建Maven项目
mvn archetype:generate
mvn archetype:generate -DgroupId=com.kanghe -DartifactId=test -Dversion=1.0
3、pom.xml
groupId、artifactId、version（依赖的坐标）
dependencyManagement（声明依赖，并不实现引入，管理依赖jar版本号）
dependencies（项目依赖）
modules（聚合工程的模块定义）
build
    plugins（构建过程中用到的插件）
    plugin
        maven-compiler-plugin（编译Java源码）
        maven-dependency-plugin（复制依赖的jar包到指定的文件夹里）
二、Dubbo

三、Zookeeper

四、Redis
内存模型、持久化、主从复制（及读写分离）、哨兵、集群
Redis3.0
1、Redis内存模型
a、Redis内存统计
    info memory
    info命令可以显示redis服务器的许多信息，包括服务器基本信息、CPU、内存、持久化、客户端连接信息等等；
    memory是参数，表示只显示内存相关的信息；
b、Redis内存划分
    数据：5种对象类型（字符串、哈希、列表、集合、有序集合）
    进程本身需要的内存
    缓冲内存
    内存碎片
    Redis对象有5种类型；无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储
c、Redis的对象类型与内部编码
2、Redis持久化
Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；
当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。
    RDB持久化（快照持久化，将进程数据写入文件）
        触发条件：手动触发和自动触发
        命令：bgsave（创建子进程创建RDB文件）
        save m n（指定当m秒内发生n次变化时，会触发bgsave）
        其他自动触发机制：在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点；
                       执行shutdown命令时，自动执行rdb持久化；
        执行流程：1)Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，
                  如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，
                  主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。
                2)父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令；
                3)父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令；
                4)子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换；
                5)子进程发送信号给父进程表示完成，父进程更新统计信息；
    AOF持久化（将Redis执行的每次写命令记录到单独的日志文件中）
        当Redis重启时再次执行AOF文件中的命令来恢复数据，与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。
        开启AOF
            Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：appendonly yes
        执行流程
            命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；
            文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；
            文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。
                过期的数据不再写入文件;
                无效的命令不再写入文件;
                多条命令可以合并为一个;
            文件重写的触发，分为手动触发（bgrewriteaof）和自动触发：
    持久化策略选择：
        如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF；
        主从环境下，
        master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好；
        slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，
        并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。
3、Redis主从复制
主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。
前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。
持久化侧重解决的是Redis数据的单机备份问题（从内存到硬盘的备份）；
主从复制侧重解决数据的多机热备；此外，主从复制还可以实现负载均衡和故障恢复。
主从复制作用：
    数据冗余（数据的热备份，是持久化之外的一种数据冗余方式）
    故障恢复（主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复）
    负载均衡（读写分离，由主节点提供写服务，由从节点提供读服务）
    高可用基石（哨兵和集群能够实施的基础）
主从复制实现原理：
    连接建立阶段
        保存主节点信息
            从节点开启主从复制：slaveof <masterip> <masterport>
            slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。
        建立socket连接
            从节点每秒1次调用复制定时函数replicationCron()，根据主节点的ip和port，创建socket连接；
            从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。
            主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，
            并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。
        发送ping命令
            发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求；
        身份验证
            如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；
        发送从节点端口信息
            身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；
    数据同步阶段
        主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化；
        根据主从节点当前状态的不同，可以分为全量复制和部分复制；
        需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端；
    命令传播阶段
        主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性；
        主从节点还维持着心跳机制：PING和REPLCONF ACK
全量复制和部分复制
心跳机制
应用中的问题
    读写分离及其中的问题
        延迟与不一致问题
        数据过期问题
4、Redis哨兵（Redis Sentinel）
它基于Redis主从复制，主要作用便是解决主节点故障恢复的自动化问题，进一步提高系统的高可用性；
缺陷：写操作无法负载均衡；存储能力受到单机的限制。
哨兵的核心功能是主节点的自动故障转移。
5、Redis集群（Redis Cluster）
解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。
集群由多个节点(Node)组成，Redis的数据分布在这些节点中。
集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。
作用：
a、数据分区：数据分区(或称数据分片)是集群最核心的功能。
b、高可用：支持主从复制和主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群任然可以对外提供服务。
6、注解缓存的使用
@Cacheable：在方法执行前Spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；没有则调用方法并将方法返回值放进缓存。
@CachePut：将方法的返回值放到缓存中。
@CacheEvict：删除缓存中的数据。
五、MQ

六、Apollo

七、Session跨域共享

八、自动化部署

九、Web服务器

十、持久层高并发

十一、分布式接口

十二、Spring Cloud

十三、搜素引擎

十四、容器技术
1、Docker

十五、JVM优化

十六、Java程序性能优化

十七、数据库优化

十八、服务器优化

十九、Linux服务器优化
